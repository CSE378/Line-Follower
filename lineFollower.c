#pragma config(Sensor, S3,     lightSensor,    sensorLightActive)
#pragma config(Motor,  motorA,          rightWheel,    tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftWheel,     tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// Readings for black color
int black = 15;
// Readings for white color
int white = 45;
// Straight and turn speed of robot
int speed = 10;
// Buffertime when going straight
int straightBufferTime = 1000;
// Buffertime when turning
int turnBufferTime = 200;
// Amount of time to check left turn with
int ticks = 22500;
// Array storing motion information
int motionArray[200][3];
// Number of motions in array
int motionCount = 0;
int errorMargin = 5;

void turnToTrack();
void continueTrack();

bool isBlack() {
	return abs(SensorValue[lightSensor] - black) <= errorMargin;
}

bool isWhite() {
	return abs(SensorValue[lightSensor] - white) <= errorMargin;
}

void turnLeft(int power) {
	motor[leftWheel] = -power;
	motor[rightWheel] = power;
}

void turnRight(int power) {
	motor[leftWheel] = power;
	motor[rightWheel] = -power;
}

void goStraight(int power) {
	motor[leftWheel] = power;
	motor[rightWheel] = power;
}

void stopWheels() {
	motor[leftWheel] = 0;
	motor[rightWheel] = 0;
}

void writeMotion(int leftWheelSpeed, int rightWheelSpeed, int duration){
	motionArray[motionCount][0] = leftWheelSpeed;
	motionArray[motionCount][1] = rightWheelSpeed;
	motionArray[motionCount][2] = duration;

	motionCount = motionCount + 1;
}

void continueTrack() {
	clearTimer(T1);
	goStraight(speed);
	// Wait until not black
	while(isBlack());
	// Wait time due to sensor being ahead of robot
	wait1Msec(straightBufferTime);
	int motionTime = time1[T1];
	writeMotion(speed, speed, motionTime);
	turnToTrack();
}

void turnToTrack() {
	clearTimer(T1);
	// Customize tick to measure how long to check turn
	int tick = 0;
	clearTimer(T1);
	// Check left turn first for number of ticks
	turnLeft(speed);
	while(isWhite() && tick < ticks) {
		tick = tick + 1;
	}
	// If left turn worked, record in txt file and continue on path
	// Turn buffer to get robot straight on track
	wait1Msec(turnBufferTime);
	int leftMotionTime = time1[T1];
	if (isBlack()) {
		writeMotion(-speed, speed, leftMotionTime);
		continueTrack();
	}
	// Else, we use a right turn and record that instead
	clearTimer(T1);
	turnRight(speed);
	while(isWhite());
	// Turn buffer to get robot straight on track
	wait1Msec(turnBufferTime);
	// Subtract left motion time to compensate for left turn adding time
	int rightMotionTime = time1[T1] - leftMotionTime;
	writeMotion(speed, -speed, rightMotionTime);
	continueTrack();
}
void init() {
	SensorType[lightSensor] = sensorLightActive;
	motionCount = 0;
	stopWheels();
}

task main()
{
	init();
	continueTrack();
}
